<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script data-consolejs-channel="b6e9c37b-c445-bb4a-1927-4584488fbdd9" src="https://remotejs.com/agent/agent.js"></script>
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { MindARThree } from 'mindar-image-three';

    document.addEventListener('DOMContentLoaded', () => {
      const start = async () => {
        // initialize MindAR
        const mindarThree = new MindARThree({
          container: document.body,
          imageTargetSrc: './assets/textures/unfoldingQR.mind',
        });
        const { renderer, scene, camera } = mindarThree;

        // preload images
        const imagesTotal = 16;
        const imageNum = Array.from({ length: imagesTotal }, (value, index) => index.toString());

        const textureLoader = new THREE.TextureLoader();
        const textures = [];

        for (let i = 0; i < imageNum.length; i++) {
          const texture = textureLoader.load(`./assets/textures/image${imageNum[i]}.jpg`);
          textures.push(texture);
        }

        // create AR object
        const geometry = new THREE.SphereGeometry(0.95, 32);
        const material = new THREE.MeshBasicMaterial({ map: textures[0], transparent: true, opacity: 0 });
        const plane = new THREE.Mesh(geometry, material);

        const geoCircle = new THREE.SphereGeometry(1, 32);
        const matCircle = new THREE.MeshBasicMaterial({
          map: textures[0],
          transparent: false,
          opacity: 1,
          side: THREE.BackSide,
        });
        const circle = new THREE.Mesh(geoCircle, matCircle);
        circle.rotation.y -= THREE.MathUtils.degToRad(270);

        // create anchor
        const anchor = mindarThree.addAnchor(0);
        anchor.group.add(plane);
        anchor.group.add(circle);

        // Create and add tori
        const tori = [];
        const colors = [0x00ff00, 0xff0000, 0x0000ff, 0xff00ff];
        const initialZ = camera.position.z - 0; // Start at the camera position
        const totalDistance = 5.5; // Total distance for the loop
        const speed = 0.15; // units per second
        const numTori = colors.length;
        const interval = (totalDistance / numTori) / speed * 1000; // Interval in milliseconds
        const loopDuration = totalDistance / speed; // Total duration for one loop
        const dissolveDuration = 45; // Duration of the dissolve effect in seconds

        function createTorus(color, delay) {
          const material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
          const torus = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.1, 16, 48), material);
          torus.position.set(0, 0, initialZ); // Set initial position along z-axis
          torus.scale.set(1, 1, 1); // Initial scale
          tori.push({ torus, delay });
        }

        colors.forEach((color, index) => {
          createTorus(color, index * interval);
        });

        function addToriToScene(currentTime) {
          tori.forEach(({ torus, delay }) => {
            if (currentTime >= delay && !torus.added) {
              scene.add(torus);
              torus.added = true;
              torus.startTime = delay;
            }
          });
        }

        let lastTime = performance.now();

        function animate(currentTime) {
          const delta = (currentTime - lastTime) / 1000; // Convert to seconds
          lastTime = currentTime;

          addToriToScene(currentTime);

          tori.forEach(({ torus, delay }) => {
            if (torus.added) {
              const elapsed = (currentTime - delay) / 1000; // Convert to seconds
              const cycleTime = elapsed % loopDuration; // Time elapsed in one loop cycle

              const z = initialZ - (cycleTime / loopDuration) * totalDistance;
              torus.position.z = z;

              if (cycleTime >= loopDuration - dissolveDuration) {
                torus.material.opacity = 1 - (cycleTime - (loopDuration - dissolveDuration)) / dissolveDuration;
              } else {
                torus.material.opacity = 1;
              }

              const scale = 1 - (cycleTime / loopDuration / 2.5);
              torus.scale.set(scale, scale, scale);

              if (z <= initialZ - totalDistance) {
                torus.scale.set(1, 1, 1);
              }
            }
          });

          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }

        animate(lastTime);

        // Create the OrbitControls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Enable damping (inertia)
        controls.dampingFactor = 0.25; // Damping factor
        controls.screenSpacePanning = false; // Do not allow panning
        controls.minDistance = 1; // Minimum zoom distance
        controls.maxDistance = 10; // Maximum zoom distance

        // start AR
        await mindarThree.start();
        renderer.setAnimationLoop(() => {
          plane.lookAt(new THREE.Vector3());
          const axisY = plane.rotation.y;

          const stepSize = 0.025; // size of each step between -0.3 and 0.3
          const numSteps = 16; // number of steps between -0.3 and 0.3

          // distribute and change images according to axisY rotation
          if (axisY <= -0.3) {
            circle.material.map = textures[0];
          } else if (axisY > 0.3) {
            circle.material.map = textures[15];
          } else {
            const index = Math.floor((axisY + 0.3) / stepSize);
            circle.material.map = textures[index];
          }

          renderer.render(scene, camera);
        });
      };
      start();
    });
  </script>
  <style>
    html, body {position: relative; margin: 0; width: 100%; height: 100%; overflow: hidden}
  </style>
</head>
<body>
</body>
</html>
